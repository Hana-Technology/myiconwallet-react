{"version":3,"sources":["../src/Icx.js"],"names":["Icx","transport","decorateAppAPIMethods","path","boolDisplay","boolChaincode","paths","buffer","Buffer","length","forEach","element","index","writeUInt32BE","send","then","result","publicKeyLength","response","publicKey","slice","toString","addressLength","address","chainCode","rawTxAscii","offset","rawTx","toSend","maxChunkSize","chunkSize","copy","push","data","i","apduResponse","signedRawTxBase64","hashHex","majorVersion","minorVersion","patchVersion","privateKeyHex","parseInt","substr"],"mappings":"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","file":"Icx.js","sourcesContent":["/********************************************************************************\n *   Ledger JS API for ICON\n *   (c) 2018 ICON Foundation\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ********************************************************************************/\n//@flow\n\n// FIXME drop:\nimport { splitPath, foreach, hexToBase64 } from \"./utils\";\nimport type Transport from \"@ledgerhq/hw-transport\";\n\n/**\n * ICON API\n *\n * @example\n * import Icx from \"@ledgerhq/hw-app-icx\";\n * const icx = new Icx(transport)\n */\nexport default class Icx {\n  transport: Transport<*>;\n\n  constructor(transport: Transport<*>) {\n    this.transport = transport;\n    transport.decorateAppAPIMethods(\n      this,\n      [\n        \"getAddress\",\n        \"signTransaction\",\n        \"getAppConfiguration\",\n        \"setTestPrivateKey\"\n      ],\n      \"ICON\"\n    );\n  }\n\n  /**\n   * Returns public key and ICON address for a given BIP 32 path.\n   * @param path a path in BIP 32 format\n   * @option boolDisplay optionally enable or not the display\n   * @option boolChaincode optionally enable or not the chaincode request\n   * @return an object with a publickey(hexa string), address(string) and \n   *  (optionally) chaincode(hexa string)\n   * @example\n   * icx.getAddress(\"44'/4801368'/0'\", true, true).then(o => o.address)\n   */\n  getAddress(\n    path: string,\n    boolDisplay?: boolean = false,\n    boolChaincode?: boolean = true\n  ): Promise<{\n    publicKey: string,\n    address: string,\n    chainCode?: string\n  }> {\n    let paths = splitPath(path);\n    let buffer = new Buffer(1 + paths.length * 4);\n    buffer[0] = paths.length;\n    paths.forEach((element, index) => {\n      buffer.writeUInt32BE(element, 1 + 4 * index);\n    });\n    return this.transport\n      .send(\n        0xe0,\n        0x02,\n        boolDisplay ? 0x01 : 0x00, \n        boolChaincode ? 0x01 : 0x00, \n        buffer\n      )\n      .then(response => {\n        let result = {};\n        let publicKeyLength = response[0];\n        result.publicKey = response.slice(1, 1 + publicKeyLength).toString(\"hex\");\n        let addressLength = response[1 + publicKeyLength];\n        result.address = response.slice(1 + publicKeyLength + 1, 1 + publicKeyLength + 1 + addressLength);\n        if (boolChaincode) {\n          result.chainCode = response.slice(-32).toString(\"hex\");\n        }\n        return result;\n      });\n  }\n\n  /**\n   * Signs a transaction and returns signed message given the raw transaction\n   * and the BIP 32 path of the account to sign\n   * @param path a path in BIP 32 format\n   * @param rawTxAscii raw transaction data to sign in ASCII string format\n   * @return an object with a base64 encoded signature and hash in hexa string\n   * @example\n   * icx.signTransaction(\"44'/4801368'/0'\",\n   *     \"icx_sendTransaction.fee.0x2386f26fc10000.\" +\n   *     \"from.hxc9ecad30b05a0650a337452fce031e0c60eacc3a.nonce.0x3.\" +\n   *     \"to.hx4c5101add2caa6a920420cf951f7dd7c7df6ca24.value.0xde0b6b3a7640000\")\n   *   .then(result => ...)\n   */\n  signTransaction(\n    path: string,\n    rawTxAscii: string\n  ): Promise<{\n    signedRawTxBase64: string,\n    hashHex: string\n  }> {\n    let paths = splitPath(path);\n    let offset = 0;\n    let rawTx = new Buffer(rawTxAscii);\n    let toSend = [];\n    let response;\n    while (offset !== rawTx.length) {\n      let maxChunkSize = offset === 0 ? 150 - 1 - paths.length * 4 - 4: 150;\n      let chunkSize =\n        offset + maxChunkSize > rawTx.length\n          ? rawTx.length - offset\n          : maxChunkSize;\n      let buffer = new Buffer(\n        offset === 0 ? 1 + paths.length * 4 + 4 + chunkSize : chunkSize\n      );\n      if (offset === 0) {\n        buffer[0] = paths.length;\n        paths.forEach((element, index) => {\n          buffer.writeUInt32BE(element, 1 + 4 * index);\n        });\n        buffer.writeUInt32BE(rawTx.length, 1 + 4 * paths.length);\n        rawTx.copy(buffer, 1 + 4 * paths.length + 4, offset, offset + chunkSize);\n      } else {\n        rawTx.copy(buffer, 0, offset, offset + chunkSize);\n      }\n      toSend.push(buffer);\n      offset += chunkSize;\n    }\n    return foreach(toSend, (data, i) =>\n      this.transport\n        .send(0xe0, 0x04, i === 0 ? 0x00 : 0x80, 0x00, data)\n        .then(apduResponse => {\n          response = apduResponse;\n        })\n    ).then(() => {\n      let result = {};\n      // r, s, v are aligned sequencially\n      result.signedRawTxBase64 = \n        hexToBase64(response.slice(0, 32 + 32 + 1).toString(\"hex\"));\n      result.hashHex = \n        response.slice(32 + 32 + 1, 32 + 32 + 1 + 32).toString(\"hex\");\n      return result;\n    });\n  }\n\n  /**\n   * Returns the application configurations such as versions.\n   * @return  major/minor/patch versions of Icon application\n   */\n  getAppConfiguration(): Promise<{\n    majorVersion: number,\n    minorVersion: number,\n    patchVersion: number\n  }> {\n    return this.transport\n      .send(0xe0, 0x06, 0x00, 0x00)\n      .then(response => {\n        let result = {};\n        result.majorVersion = response[0];\n        result.minorVersion = response[1];\n        result.patchVersion = response[2];\n        return result;\n      });\n  }\n\n  /**\n   * Sets the given key as the test purpose private key corresponding to \n   * \"\\0'\" of BIP 32 path just for test purpose. After calling this function,\n   * all functions with \"\\0'\" path works based on this private key. \n   * REMARK: Test purpose only such as verifying signTransaction function. \n   * @param privateKeyHex private key in hexadecimal string format\n   * @example\n   * icx.setTestPrivateKey(\"23498dc21b9ee52e63e8d6566e0911ac255a38d3fcbc68a51e6b298520b72d6e\")\n   *   .then(result => ...)\n   * icx.getAddress(\"0'\", false, false).then(o => o.address)\n   */\n  setTestPrivateKey(privateKeyHex: string) {\n    let data = new Buffer(32);\n    for (let i = 0; i < privateKeyHex.length; i += 2) {\n      data[i / 2] = parseInt(privateKeyHex.substr(i, 2), 16);\n    }\n    return this.transport.send(0xe0, 0xff, 0x00, 0x00, data).then();\n  }\n}\n"]}